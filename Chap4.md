
#4장 표현식과 연산자
##4.1 원시 표현식
- 1. 상수, 리터럴값, 특정 언어 키워드들, 변수참조를 말한다
```javascript
  1.23 //숫자리터럴
  "hello" //문자열 리터럴
  /pattern/ //정규표현식 리터럴
```
- 2. 일부 예약어
```javascript
  true
  false
  null
  this //현재객체, 프로그램 안에서 위치에 따라 각기 다른 값으로 평가
```
- 3. 변수를 있는 그대로 참조
```javascript
  i //변수 i의값
  sum //변수 sum의 값
  undefined //undefined는 전역변수
```

##4.2객체와 배열의 초기화 표현식
- 객체나 배열을 값으로 하는 표현식
- 객체리터럴과 배열리터럴
```javascript
  //배열초기화표현식
  [] //빈 배열
  [1+2, 3+4] //두개의 원소를 가진 배열
  var matrix =[[1,2,3], [4,5,6], [7,8,9]];
  var sparseArray = [1,,,,5];
  
  //객체초기화표현식
  var p = { x:2.3, h:-1.2 }; //두개의 프로퍼티를 가진 객체
  var q = {};
  q.x = 2.3; q.y = -1.2; //q와 p는같은 프로퍼티를 갖는다
  var rectangle = {upperLeft: {x:2, y:2}, lowerRight: {x:4, y:5}}; //객체 리터럴은 중첩될 수 있다
```
- 배열 초기화 표현식에 사용한, 객체초기화 표현식에 사용한 표현식은 초기화 될때마다 매번 평가되므로일정한 값을 갖지 않는다
- 객체리터럴의 프로퍼티 이름은 식별자 보다 문자열을 사용하는 편이 낫다
```javascript
  var side = 1;
  var square = {"upperLeft": {x:p.x, y:p.y},
                "lowerRight": {x:p.x, +side, y:p.y + side} };
```

##4.3함수 정의 표현식
- 함수정의 표현식은 함수리터럴

##4.4 프로퍼티 접근 표현식
- 객체의 프로퍼티나 배열의 원소 값
- 표현식.식별자 // 표현식은 객체, 식별자는 프로퍼티의 이름
- 표현식[표현식]
```javascript
  var o = {x:1, y:{z:3}};
  var a = [o,4,[5,6]];
  o.x;
  o.y.z
  o["x"]
  a[1]
  a[2]
  a["1"]
  a[0].x
```
- null이나 undefined의 프로퍼티에 접근시 TypeError를 발생
- 값이 객체(배열)이 아니면 객체로 바뀐다
- 객체표현식 다음에 두번째 표현식이 담긴 대괄호가 오면 이 표현식이 평가되고 문자열로 변환된다. 이 변환된 문자열을 프로퍼티 이름으로 하는 값이 도출된다
- ".식별자" : 객체에 해당 식별자를 이름으로 하는 프로퍼티 가 있을 경우만 사용가능, 또 식별자를 알고 있어야 사용가능
- 프로퍼티 이름이 예약어이거나, 구두 문자나 공백을 포함한 경우, 숫자(배열)일 때 반드시 대괄호 표기법을 사용해야한다

##4.5 호출 표현식
- 호출표현식은 함수나 메서드 호출하는 문법
```javascript
  f(0)
  Math.max(x,y,z)
  a.sort()
```
- return 구문 사용시 최종 값은 함수 표현식의 값
- return 구문 미사용시 함수 표현식의 값은 undefined
- 프로퍼티접근표현식의 경우 호출표현식은 메서드 호출임
- 함수가 실행되는 동안 프로퍼티 접근 표현식이 가리키는 객체나 배열이 모두 this의 매개변수가 됨
- 메서드 호출이 아닌 호출 표현식은 보통 전역객체를 this키워드의 값으로 사용

##4.6 객체 생성 표현식
- 새 객체를 생성하고 생성자 함수를 호출해 객체에 속한 프로퍼티들을 초기화
```javascript
  new Object()
  new Point(2,3)
  new Object //인자없이 호출시 괄호생략가능
  new Date //인자없이 호출시 괄호생략가능
```

##4.7 연산자 살펴보기
- +나-같은 문장부호, delete와 instanceof같은 키워드로 표현

##4.7.1 피연산자 개수
- 2항연산자 : 1+2
- 단항 연산자 : -x
- 3항 연산자 : ?:

##4.7.2 피연산자와 반환 타입
- 일부 연산자들은 피연산자 타입에 따라 다르게 동작
- +연산 : 피연산자가 숫자면 덧셈, 문자열이면 이어붙인다
- <같은 비교연산 : 숫자나 문자열 알파벳 순서로 비교

##4.7.3 좌변 값
- 좌변 값 : 할당 표현식의 좌변에 나타날 수 있는 표현식
- 변수, 객체 프로퍼티, 배열 원소가 좌변 값

##4.7.4 연산자 부수 효과
- 할당연산자 : 변수나 객체의 프로퍼티에 값을 할당하면 변수나 프로퍼티를 사용한 모든 표현식의 값을 바꾼다
- 증가연산자와 감소연산자 : 기존의 값을 변경하는 묵시적 할당
- delete연산자 : 해당 프로퍼티에 undefined를 할당하는 것과 유사

##4.7.5 연산자 우선순위
- 연산자 우선순위 : 연산이 수행되는 순서를 제어하는 기준
- 곱셈이 덧셈보다 먼저 수행, 할당 연산자는 우선순위가 가장 낮다
- 프로퍼티 접근이나 호출 표현식은 항상 우선순위가 높다
- 괄호를 이용해 연산 순서를 명시적으로 제한하기

##4.7.6 연산자 결합방향

##4.7.7 평가순서

##4.8 산술 표현식
- 자바스크립트에서 모든 숫자는 부동소수점 숫자로 취급된다
- 모든 나눗셈 연산의 결과가 부동소수점 숫자가 된다
- 0으로 나눈면 양의무한대 또는 음의무한대
- 0/0은 NaN
- %연산자의 결과 부호는 첫번재 피연산자의 부호와 동일
- 5%2 = 1 이고 -5%2 = -1 이다

##4.8.1 덧셈연산자 +
- 숫자값을 더하거나 문자열을 이어붙인다
- 타입변환 시 문자열 이어 붙이기를 우선으로 수행된다
- 하나의 피연산자가 객체면 얘를 원시타입으로 바꾼다. 
- Date객체는 toString()메서드에 의해 문자열로, 다른객체는 valueOf()메서드에 의해 변경
- 피연산자가 원시타입으로 변환 된 후, 만일 하나의 피연산자가 문자열이면 다른 피연산자를 문자열로 변환한 후 두 문자열을 이어붙인다
- 이 외의 경우 두 피연산자가 숫자(또는 NaN)로 변환되고 덧셈연산이 수행된다
```javascript
  1+2 //3
  "1" + "2" //"12"
  "1" + 2 //"12"
  1 + {} //"1[object Object]" :객체를 문자열로 바꾼 후 이어붙이기
  true + true //2 :불리언값을 숫자롭 바꾼 후 이어붙이기
  2 + null //2 :null값을 0으로 바꾼 후 더하기
  2 + undefined //NaN :undefined를 NaN으로 바꾼 후 더하기
  1 + 2 + " blind mice" //"3 blind mice"
  1 + (2 + " blind mice") //"12 blind mice" : 연산 순서에 따라 결과가 달라진다
```

##4.8.2 단항 산술 연산자
- 단항연산자 : 하나의 피연산자 값을 수정해 새 값으로 만든다
- 가장 우선순위가 높다
- 결합방법은 오른쪽에서왼쪽
- 1. 단항덧셈
- 피연산자를 숫자 또는 NaN으로 바꾼 후 진행
- 2. 단항뺄셈
- 부호를 바꾼다
- 3. 증가(++)
- 1을 더한다
- 피연산자는 반드시 좌변값(변수, 배열원소 또는 객체 프로퍼티중 하나)이어야한다
- 피연산자 앞에서 사용될 경우 전치증가
- 뒤에서 사용될 경우 후치증가
- 4. 감소(--)
- 1을 뺀다
- 피연산자 앞에 있으면 감소시킨 값을 반환
- 뒤에 있으면 갑소시키기 전의 값 반환

##4.8.3 비트 단위 연산자
- 2진수를 저수준에서 조작하는데서 사용
- 비트연산자 네종류*&, |, ^, ~)는 피연산자의 개별 비트에 대해 불리언 대수를 수행
- 피연산자의 개별비트는 불리언값으루 취급한다(1=true, 0=false)
- 32비트 정수 표현법을 따른다
- 이동연산자의 우측 피연산자는 0과 31사이의 값이어야한다
- NaN, 양의무한대, 음의무한대는 비트연산자의 피연산자로 사용시 모두 값이 0이다
- 1. 비트단위 AND(&)
- 2. 비트단위 OR(|)
- 3. 비트단위 XOR(^)
- 두 연산자중 하나가 true지만 둘다 true는 아닐때때
- 4. 비트단위 NOT(~)
- 그 값의 부호를 바꾸고 1을 빼는 결과
- 5. 왼쪽으로 이동(<<)
- 첫번째 피연산자를 두번째피연산자에 지정한 값만큼 왼쪽으로 이동
- 두번째 피연산자는 반드시 0과 31사이의 값이어야한다
- 모든 비트들이 이동하면 첫번재 비트를 새로 만들어야하는데 이로는 0이 사용되며 32번째 비트는 잃어버리게 된다
- 왼쪽으로 한자리 이동은 2를 곱하는 것, 두자리이동은 4를 곱하는 것과 같다
- 6. 부호를 보전하며 오른쪽으로 이동(>>)
- 왼쪽 자리에 채워질 비트는 최초 피연산자의 부호비트가 된다
- 첫 번째 피연산자가 양수면, 결과 값의 최상위 비트가 0이 되고 음수면 1이된다. 
- 오늘쪽으로 한자리 이동은 2로 나누는 것, 두자리 이동은 4로 나누는 것과 같다
- 7. 0으로 채우면서 오른쪽으로 이동(>>>)
- 왼쪽 자리에 새로 들어오는 비트가 첫 번째 피연산자의 부호에 관계없이 무조건 0

##4.9 관계형 표현식
- 항상 불리언 값으로 표현됨
- if, while, for문에서 사용된다 

##4.9.1 동등과 부등 연산자
- ===연산자 : 일치연산자
- ==연산자 : 동등연산자
- =연산자 : 할당연산자
- !=연산자 : 부등연산자
- !==연산자 : 불일치연산자
- !연산자 : NOT연산자

* 일치연산자(===)의 규칙
- 타입이 다르면 일치하지 않는다
- 두 값이 모두 null이거나 undefined이면 일치한다
- 두 값이 모두 불리언값true,false면 일치한다
- 적어도 하나가 NaN이면 일치하지 않는다
- NaN은 자기자신을 포함해 어떤 값과도 일치하지 않는다
- x가 NaN인지 검사하기 위해서는 x!==x를 사용한다
- 두값이 모두 숫자고 같은 값이면 두 값은 일치한다
- 두 값이 문자열이고 같은 위치에 정확히 같은 16비트 문자열을 가지고 있으면 일치한다
- 두 값이 같은 객체나 배열 또는 함수를 참조하면 두 값은 일치한다

* 동등연산자(==)의 규칙
- 타입이 같은 경우 값이 동등하면 두 값이 같다
- 두 값중 하나가  null이고 하나가 undefined라면 동등하다
- 하나가 숫자고 하나가 문자열이면 문자열을 숫자로 변환후 비교한다
- 둘 중 하나가 true면 이것을 1로 변환 후, false면 0으로 변환 후 다시 비교한다
- 하나가 객체고 다른 하나가 숫자 또는 문자열이면 해당 객체의toString()메서드나 valueOf()메서드를 이용해 객체를 원시타입의 값으로 변환 후 다시 비교
```javascript
  "1" == true
```

##4.9.2 비교 연산자
- <, >, <=, >=
- 숫자와 문자열만 비교할 수 있다
- 숫자나 문자열이 아닌 피연산잔느 먼저 변환된다
- 피연산자 중 하나가 객체면 원시값으로 변환된다 
- 원시타입으로 변환된 후에 피연산자가 모두 문자열이라면 '알파벳 순서'대로 두 문자열을 비교한다
- 피연산자 중 하나가 문자열이 아니면, 피연산자 모두 숫자로 변환된 후 값을 비교한다
- 자바스크립트 문자열은 16비트 정수값들의 나열
- 문자열 비교는 각 문자에 해당하는 숫자값으로 비교
- ASCII대문자는 모든 ASCII소문자보다 '작다'
- String.tolocaleCompare()메서드 : 각 로케일에 따른 알파벳 순서를 고려
- String.toLowerCase() : 모두 소문자로
- String.toUpperCase() : 모두 대문자로
```javascript
  1+2 //3
  "1" + "2" //"12"
  "1" + 2 //"12"
  11 < 3 //false
  "11" < "3" //true :숫자비교
  "11" < 3 //false :숫자비교
  "one" < 3 //false :숫자비교
```
- + 연산자는 문자열을 선호
- 비교연산자는 숫자를 선호, 두 피연산자들이 문자열일 때만 문자열 비교
- 두 피연산자 중 하나가 NaN이면, 네 종류의 비교 연산자 모두 false를 반환
