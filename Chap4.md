
#4장 표현식과 연산자
##4.1 원시 표현식
- 1. 상수, 리터럴값, 특정 언어 키워드들, 변수참조를 말한다
```javascript
  1.23 //숫자리터럴
  "hello" //문자열 리터럴
  /pattern/ //정규표현식 리터럴
```
- 2. 일부 예약어
```javascript
  true
  false
  null
  this //현재객체, 프로그램 안에서 위치에 따라 각기 다른 값으로 평가
```
- 3. 변수를 있는 그대로 참조
```javascript
  i //변수 i의값
  sum //변수 sum의 값
  undefined //undefined는 전역변수
```

##4.2객체와 배열의 초기화 표현식
- 객체나 배열을 값으로 하는 표현식
- 객체리터럴과 배열리터럴
```javascript
  //배열초기화표현식
  [] //빈 배열
  [1+2, 3+4] //두개의 원소를 가진 배열
  var matrix =[[1,2,3], [4,5,6], [7,8,9]];
  var sparseArray = [1,,,,5];
  
  //객체초기화표현식
  var p = { x:2.3, h:-1.2 }; //두개의 프로퍼티를 가진 객체
  var q = {};
  q.x = 2.3; q.y = -1.2; //q와 p는같은 프로퍼티를 갖는다
  var rectangle = {upperLeft: {x:2, y:2}, lowerRight: {x:4, y:5}}; //객체 리터럴은 중첩될 수 있다
```
- 배열 초기화 표현식에 사용한, 객체초기화 표현식에 사용한 표현식은 초기화 될때마다 매번 평가되므로일정한 값을 갖지 않는다
- 객체리터럴의 프로퍼티 이름은 식별자 보다 문자열을 사용하는 편이 낫다
```javascript
  var side = 1;
  var square = {"upperLeft": {x:p.x, y:p.y},
                "lowerRight": {x:p.x, +side, y:p.y + side} };
```

##4.3함수 정의 표현식
- 함수정의 표현식은 함수리터럴

##4.4 프로퍼티 접근 표현식
- 객체의 프로퍼티나 배열의 원소 값
- 표현식.식별자 // 표현식은 객체, 식별자는 프로퍼티의 이름
- 표현식[표현식]
```javascript
  var o = {x:1, y:{z:3}};
  var a = [o,4,[5,6]];
  o.x;
  o.y.z
  o["x"]
  a[1]
  a[2]
  a["1"]
  a[0].x
```
- null이나 undefined의 프로퍼티에 접근시 TypeError를 발생
- 값이 객체(배열)이 아니면 객체로 바뀐다
- 객체표현식 다음에 두번째 표현식이 담긴 대괄호가 오면 이 표현식이 평가되고 문자열로 변환된다. 이 변환된 문자열을 프로퍼티 이름으로 하는 값이 도출된다
- ".식별자" : 객체에 해당 식별자를 이름으로 하는 프로퍼티 가 있을 경우만 사용가능, 또 식별자를 알고 있어야 사용가능
- 프로퍼티 이름이 예약어이거나, 구두 문자나 공백을 포함한 경우, 숫자(배열)일 때 반드시 대괄호 표기법을 사용해야한다

##4.5 호출 표현식
- 호출표현식은 함수나 메서드 호출하는 문법
```javascript
  f(0)
  Math.max(x,y,z)
  a.sort()
```
- return 구문 사용시 최종 값은 함수 표현식의 값
- return 구문 미사용시 함수 표현식의 값은 undefined
- 프로퍼티접근표현식의 경우 호출표현식은 메서드 호출임
- 함수가 실행되는 동안 프로퍼티 접근 표현식이 가리키는 객체나 배열이 모두 this의 매개변수가 됨
- 메서드 호출이 아닌 호출 표현식은 보통 전역객체를 this키워드의 값으로 사용

##4.6 객체 생성 표현식
- 새 객체를 생성하고 생성자 함수를 호출해 객체에 속한 프로퍼티들을 초기화
```javascript
  new Object()
  new Point(2,3)
  new Object //인자없이 호출시 괄호생략가능
  new Date //인자없이 호출시 괄호생략가능
```

##4.7 연산자 살펴보기
- +나-같은 문장부호, delete와 instanceof같은 키워드로 표현

##4.7.1 피연산자 개수
- 2항연산자 : 1+2
- 단항 연산자 : -x
- 3항 연산자 : ?:

##4.7.2 피연산자와 반환 타입
- 일부 연산자들은 피연산자 타입에 따라 다르게 동작
- +연산 : 피연산자가 숫자면 덧셈, 문자열이면 이어붙인다
- <같은 비교연산 : 숫자나 문자열 알파벳 순서로 비교

##4.7.3 좌변 값
- 좌변 값 : 할당 표현식의 좌변에 나타날 수 있는 표현식
- 변수, 객체 프로퍼티, 배열 원소가 좌변 값

##4.7.4 연산자 부수 효과
- 할당연산자 : 변수나 객체의 프로퍼티에 값을 할당하면 변수나 프로퍼티를 사용한 모든 표현식의 값을 바꾼다
- 증가연산자와 감소연산자 : 기존의 값을 변경하는 묵시적 할당
- delete연산자 : 해당 프로퍼티에 undefined를 할당하는 것과 유사

##4.7.5 연산자 우선순위
- 연산자 우선순위 : 연산이 수행되는 순서를 제어하는 기준
- 곱셈이 덧셈보다 먼저 수행, 할당 연산자는 우선순위가 가장 낮다
- 프로퍼티 접근이나 호출 표현식은 항상 우선순위가 높다
- 괄호를 이용해 연산 순서를 명시적으로 제한하기

##4.7.6 연산자 결합방향

##4.7.7 평가순서

##4.8 산술 표현식
- 자바스크립트에서 모든 숫자는 부동소수점 숫자로 취급된다
- 모든 나눗셈 연산의 결과가 부동소수점 숫자가 된다
- 0으로 나눈면 양의무한대 또는 음의무한대
- 0/0은 NaN
- %연산자의 결과 부호는 첫번재 피연산자의 부호와 동일
- 5%2 = 1 이고 -5%2 = -1 이다

##4.8.1 덧셈연산자 +
- 숫자값을 더하거나 문자열을 이어붙인다
- 타입변환 시 문자열 이어 붙이기를 우선으로 수행된다
- 하나의 피연산자가 객체면 얘를 원시타입으로 바꾼다. 
- Date객체는 toString()메서드에 의해 문자열로, 다른객체는 valueOf()메서드에 의해 변경
- 피연산자가 원시타입으로 변환 된 후, 만일 하나의 피연산자가 문자열이면 다른 피연산자를 문자열로 변환한 후 두 문자열을 이어붙인다
- 이 외의 경우 두 피연산자가 숫자(또는 NaN)로 변환되고 덧셈연산이 수행된다
```javascript
  1+2 //3
  "1" + "2" //"12"
  "1" + 2 //"12"
  1 + {} //"1[object Object]" :객체를 문자열로 바꾼 후 이어붙이기
  true + true //2 :불리언값을 숫자롭 바꾼 후 이어붙이기
  2 + null //2 :null값을 0으로 바꾼 후 더하기
  2 + undefined //NaN :undefined를 NaN으로 바꾼 후 더하기
  1 + 2 + " blind mice" //"3 blind mice"
  1 + (2 + " blind mice") //"12 blind mice" : 연산 순서에 따라 결과가 달라진다
```

##4.8.2 단항 산술 연산자
- 단항연산자 : 하나의 피연산자 값을 수정해 새 값으로 만든다
- 가장 우선순위가 높다
- 결합방법은 오른쪽에서왼쪽
- 1. 단항덧셈
- 피연산자를 숫자 또는 NaN으로 바꾼 후 진행
- 2. 단항뺄셈
- 부호를 바꾼다
- 3. 증가(++)
- 1을 더한다
- 피연산자는 반드시 좌변값(변수, 배열원소 또는 객체 프로퍼티중 하나)이어야한다
- 피연산자 앞에서 사용될 경우 전치증가
- 뒤에서 사용될 경우 후치증가
- 4. 감소(--)
- 1을 뺀다
- 피연산자 앞에 있으면 감소시킨 값을 반환
- 뒤에 있으면 갑소시키기 전의 값 반환

##4.8.3 비트 단위 연산자
- 2진수를 저수준에서 조작하는데서 사용
- 비트연산자 네종류*&, |, ^, ~)는 피연산자의 개별 비트에 대해 불리언 대수를 수행
- 피연산자의 개별비트는 불리언값으루 취급한다(1=true, 0=false)
- 32비트 정수 표현법을 따른다
- 이동연산자의 우측 피연산자는 0과 31사이의 값이어야한다
- NaN, 양의무한대, 음의무한대는 비트연산자의 피연산자로 사용시 모두 값이 0이다
- 1. 비트단위 AND(&)
- 2. 비트단위 OR(|)
- 3. 비트단위 XOR(^)
- 두 연산자중 하나가 true지만 둘다 true는 아닐때때
- 4. 비트단위 NOT(~)
- 그 값의 부호를 바꾸고 1을 빼는 결과
- 5. 왼쪽으로 이동(<<)
- 첫번째 피연산자를 두번째피연산자에 지정한 값만큼 왼쪽으로 이동
- 두번째 피연산자는 반드시 0과 31사이의 값이어야한다
- 모든 비트들이 이동하면 첫번재 비트를 새로 만들어야하는데 이로는 0이 사용되며 32번째 비트는 잃어버리게 된다
- 왼쪽으로 한자리 이동은 2를 곱하는 것, 두자리이동은 4를 곱하는 것과 같다
- 6. 부호를 보전하며 오른쪽으로 이동(>>)
- 왼쪽 자리에 채워질 비트는 최초 피연산자의 부호비트가 된다
- 첫 번째 피연산자가 양수면, 결과 값의 최상위 비트가 0이 되고 음수면 1이된다. 
- 오늘쪽으로 한자리 이동은 2로 나누는 것, 두자리 이동은 4로 나누는 것과 같다
- 7. 0으로 채우면서 오른쪽으로 이동(>>>)
- 왼쪽 자리에 새로 들어오는 비트가 첫 번째 피연산자의 부호에 관계없이 무조건 0

##4.9 관계형 표현식
- 항상 불리언 값으로 표현됨
- if, while, for문에서 사용된다 

##4.9.1 동등과 부등 연산자
- ===연산자 : 일치연산자
- ==연산자 : 동등연산자
- =연산자 : 할당연산자
- !=연산자 : 부등연산자
- !==연산자 : 불일치연산자
- !연산자 : NOT연산자

* 일치연산자(===)의 규칙
- 타입이 다르면 일치하지 않는다
- 두 값이 모두 null이거나 undefined이면 일치한다
- 두 값이 모두 불리언값true,false면 일치한다
- 적어도 하나가 NaN이면 일치하지 않는다
- NaN은 자기자신을 포함해 어떤 값과도 일치하지 않는다
- x가 NaN인지 검사하기 위해서는 x!==x를 사용한다
- 두값이 모두 숫자고 같은 값이면 두 값은 일치한다
- 두 값이 문자열이고 같은 위치에 정확히 같은 16비트 문자열을 가지고 있으면 일치한다
- 두 값이 같은 객체나 배열 또는 함수를 참조하면 두 값은 일치한다

* 동등연산자(==)의 규칙
- 타입이 같은 경우 값이 동등하면 두 값이 같다
- 두 값중 하나가  null이고 하나가 undefined라면 동등하다
- 하나가 숫자고 하나가 문자열이면 문자열을 숫자로 변환후 비교한다
- 둘 중 하나가 true면 이것을 1로 변환 후, false면 0으로 변환 후 다시 비교한다
- 하나가 객체고 다른 하나가 숫자 또는 문자열이면 해당 객체의toString()메서드나 valueOf()메서드를 이용해 객체를 원시타입의 값으로 변환 후 다시 비교
```javascript
  "1" == true
```

##4.9.2 비교 연산자
- <, >, <=, >=
- 숫자와 문자열만 비교할 수 있다
- 숫자나 문자열이 아닌 피연산잔느 먼저 변환된다
- 피연산자 중 하나가 객체면 원시값으로 변환된다 
- 원시타입으로 변환된 후에 피연산자가 모두 문자열이라면 '알파벳 순서'대로 두 문자열을 비교한다
- 피연산자 중 하나가 문자열이 아니면, 피연산자 모두 숫자로 변환된 후 값을 비교한다
- 자바스크립트 문자열은 16비트 정수값들의 나열
- 문자열 비교는 각 문자에 해당하는 숫자값으로 비교
- ASCII대문자는 모든 ASCII소문자보다 '작다'
- String.tolocaleCompare()메서드 : 각 로케일에 따른 알파벳 순서를 고려
- String.toLowerCase() : 모두 소문자로
- String.toUpperCase() : 모두 대문자로
```javascript
  1+2 //3
  "1" + "2" //"12"
  "1" + 2 //"12"
  11 < 3 //false
  "11" < "3" //true :숫자비교
  "11" < 3 //false :숫자비교
  "one" < 3 //false :숫자비교
```
- + 연산자는 문자열을 선호
- 비교연산자는 숫자를 선호, 두 피연산자들이 문자열일 때만 문자열 비교
- 두 피연산자 중 하나가 NaN이면, 네 종류의 비교 연산자 모두 false를 반환

##4.9.3 in연산자
- 좌변에 문자열, 우변에 객체나 배열을 받는다
```javascript
  var point = {x:1, y:1};
  "x" in point //true
  "z" in point //false
  "toString" in point //true : 상속된 프로퍼티
  var data =[7,8,9];
  "0" in data //true : 배열의 0번째 원소
  1 in data //true : 배열의 1번째 원소
  3 in data //false : 배열의 3번째 원소
```

##4.9.4 instanceof연산자
- 좌변에 객체를, 우변에 객체 클래스의 이름을
- 좌변에 오는 객체가 우변에 오는 클래스의 인스턴스일 경우 true를 리턴
```javascript
  var d = new Date(); //Date()생성자로 새로운 객체 생성
  d instanceof Date //true : d는 Date()에 의해 생성됨 
  d instanceof Object //true : 모든 객체는 Object의 인스턴스
  d instanceof Number //false : d는 number의 객체가 아니다
  var a = [1,2,3]; // 배열 생성
  a instanceof Array //true : a는 배열이다
  a instanceof Object //true : 모든 배열은 객체다
  a instanceof RegExp //false : 배열은 정규 표현식이 아니다
```
- 모든 객체는 Object의 인스턴스
- 좌변 피연산자가 객체가 아니면 instanceof의 결과는 false
- 우변 피연산자가 함수가 아니면  TypeError 
- instanceof의 동작은 프로토타입체인의 개념
- o instanceof f의 경우 f.prototype을 살펴본 후, o의 프로토타입 체인을 살펴보며 f.prototype값을 찾는다 

##4.10 논리 표현식
##4.10.1 논리 AND(&&)
1. 두 피연산자가 불리언일 경우
- 두 피연산자의 값에 대해 불리언 AND연산 수행
```javascript
  x == 0 && y == 0
```
- 관계연산자는 &&와 ||보다 우선순위가 높다
2. 피연산자로 true로 평가되는값, false로 평가되는 값들이 올 경우
- false로 평가되는 값은 false, null undefined, 0, -0, NaN, ""
-이 외의 다른 값들(객체포함)은 true로 평가된다
3. 단락평가
- &&연산자는 좌변에 있는 첫 번째 피연산자인 표현식을 먼저 평가
- 이 것이 false로 평가되면 우변의 표현식을 평가하지 않고 false를 리턴
- 반대로 좌변이 true로 평가되면 전체표현식의 값은 우측 표현식의 값에 따라 달라짐
```javascript
  var o = { x : 1 };
  var p = null;
  o && o.x; //1 : o가 객체이므로 o.x를 반환
  p && p.x; //null : p가 null이므로 p.x를 평가하지 않고 null을 반환, p가 true로 평가될 때만 p.x가 실행된다
  p.x //TypeError : p가 null이므로 p.x를 평가하면 TypeError발생 
  
  if ( a == b ) stop(); //아래의 코드와 동일, a==b를 만족할 경우만 stop()함수 호출
  (a == b ) && stop();
```
##4.10.2 논리 OR(||)
- 두 피연산자 값에 대해 불리언 OR를 수행
- 여러 값 중 최초로 true로 평가되는 값을 사용할 경우 사용한다
```javascript
  var max = max_width || preferences.max_width || 500; 
  //max_width가 정의되었으면 이것을
  //아니면 perference객체에 속한 값을 찾아본다
  //없으면 하드코딩된 상수를 사용한다
  
  function copy(o, p) {
    p = p || {}; //p가 null이면 새롭게 객체를 생성한다
    ...
  }
```

##4.10.3 논리 NOT(!)
- !연산자는 단항연산자
- 불리언 값을 반전, 즉 반대로 바꾼다
- 피연산자를 먼저 불리언으로 바꾸고 반전시킨다
- !!x와 같이 표현하여 x에 해당하는 불리언값을 얻을수있다
- !는 우선순위가 가장 높다
```javascript
  !(p && q) === !p || !q
  !(p || q) === !p && !q
```

##4.11 할당표현식
```javascript
  i = 0
  o.x = 1
  
  (a = b) == 0 //할당하고 그 값을 테스트 하기
  
  i = j = k = 0; //할당연산이 같은 표현식에서 일어날 경우, 오른쪽에서 왼쪽으로 진행된다
  //하나의 값을 여러개의 변수에 할당할 수 있다 
```

##4.11.1 연산을 동반하는 할당
- +=할당 : 숫자나 문자열에 대해 작동
```javascript
  total += scales_tax
  total = total + scales_tax
```
- +=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, |=
- 아래와 같은 경우 주의
```javascript
  data[i++] *= 2; //data[i++]가 한번 평가됨
  data[i++] = data[i++] *2; //data[i++]가 두번 평가됨 그러므로 위와 같지 않다
```

##4.12 평가표현식
##4.12.1 eval()
- 단 하나의 전달인자를 갖는다
- 문자열을 전달하면 문자열을 자바스크립트 코드로 해석해 코드에 포함된 마지막 표현식 또는 구문의 값을 반환
- 해석하지 못하면 SyntaxError가 발생한다
- 값이 없을 경우는 undefined를 반환
- eval() 함수의 핵심은 호출되는 시점의 변수 환경을 사용한다는 점
- eval("x")를 호출하면 선언한 지역변수 x의 값이 반환된다
- eval("x=1")을 호출하면 지역변수 x의 값을 바꾼다
- eval("var y = 3")은 새 지역변수 y를 선언한다
- eval("function f() { return x+!; }")는 지역함수를 선언한다

##4.12.2 전역eval()
- eval()은 지역변수 값을 바꿀 수 있다
- 이러한기능은 최적화에 문제가된다
- 만일 eval()함수가 'eval'이 아닌 다른 이름으로 호출되면 EvalError 예외가 발생한다
- eval()을 eval이 아닌 다른 이름으로 호출한 경우, 호출된 위치가 최상위 전역 코드 영역일 경우만 문자열을 평가한다
- 이때 평가되는 코드는 새 전역변수나 함수를 선언, 전역변수를 설정할 수 있다
- 하짐나 지역변수를 사용, 수정하면 안된다
- 결국, 인터프리터가 지역코드를 최적화할 때 eval()이 영향을 미치지 않게 된다 
```javascript
  var geval = eval;
  var x = "global", y = "global";
  function f() {
    var x = "local";
    eval("x += 'changed';");
    return x;
  }
  function g() {
    var y = "local";
    geval("y += 'changed';");
    return y;
  }
  console.log(f(), x); //localchanged global : 지역변수 값이 변경되었다
  console.log(g(), y); //local globalchanged : 전역변수 값이 변경되었다
```

##4.12.3 엄격한 모드의 eval()
- 실행 시점의 지역 유효범위 내에서만 실행된다
- 기존에 선언된 지역 변수값을 설정할 수 있지만, 새 변수나 함수를 선언할 수는 없다
- "eval"을 예약어처럼 만들어서 새값으로 변경(override)할 수 없다

##4.13 기타 연산자들
##4.13.1 조건부연산자(?:)
- 자바스크립트의 유일한 3항연산자자
- 피연산자에는 어떤 타입도 올 수 있다
- 첫번째 피연산자는 불리언값으로 평가된다
- 이게 true면 두번째 피연산자가, false면 세번째 피연산자가 평가된다
```javascript
  x > 0 ? x : -x //x의 절대값구하기
  
  greeting = "hello " + (username ? username : "there");
  
  //위의 구문을 if else로 변경시 아래와 같다
  greeting = "hello ";
  if(username)
    greeting += username;
  else
    greeting += "there";
```

##4.13.2 typeof연산자
- 단항연산자로 피연산자에 어떤 타입이든 올 수 있다
- 피연산자의 데이터 타입을 가리키는 문자열을 리턴한다
- x : typeof x
- undefined : "undefined"
- null : "object"
- true 나 false : "boolean"
- 숫자 또는 NaN : "number"
- 문자열 : "string"
- 함수 : "function"
- 함수가 아닌 객체 : "object"
- 호스트객체 : "undefined"나 "boolean", "number", "string"을 제외한 구현부 정의 문자열

##4.13.3 delete연산자
```javascript
  var o = { x:1, y:2 };
  delete o.x;
  "x" in o //false
  var a = [1,2,3];
  delete a[2];
  2 in a //false
  a.length //3 : 배열길이는 변하지 않는다!!
```
- 삭제되면 그 프로퍼티는 더이상 존재하지 않는다
- 존재하지 않는 프로퍼티에 접근하려하면 undefined가 반환된다
- 배열의 원소를 삭제하면 빈자리가 생기고 배열의 길이는 변하지 않는다
- 내장 코어 프로퍼티나 클라이언트 측 프로퍼티는 삭제할 수 없다
- var문으로 정의한 변수들도 삭제할 수 없다
- 함수 구문으로 정의된 함수와 함수 매개변수로 선언한 함수 역시 삭제할 수 없다
```javascript
  var o = {x:1, y:2};
  delete o.x; //true
  typeof o.x; //"undefined" : 존재하지 않는 프로퍼티
  delete o.x; //true : 존재하지 않는 프로퍼티 삭제 true
  delete o; //false : 선언된 변수는 삭제할 수없다
  
  delete 1; //true
  this.x = 1; 
  delete x; //false : 변수x를 지우려고 한다. 엄격한 모드가 아닐때는 true반환
  
  x; //1 (책에서는 런타임 에러 발생한다고 되어있음..모냐)
```

##4.13.4 void연산자
- 피연산자를 무시하고 undefined를 반환
- void연산자를 사용하면 피연산자가 버려진다
```html
  <a herf="javascript:void window.open();">Open New Window</a> //html a태그 안에 void연산자를 쓸 수 있다
```

##4.13.5 쉼표(,)연산자
```javascript
i=0, j=1, k=2;
//아래와 같다
i=0; j=1; k=2;

for(var i=0,j=10; i<j; i++,j--)
console.log(i+j)
```
